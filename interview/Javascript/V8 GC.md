# V8 GC

## 1. 新生代空间 & 老生代空间

新生代的垃圾回收很迅速和频繁,空间很小,默认只有1-8MBs大小.

老生代是新生代太久没有被回收的会晋升到这里,这里内存分配也非常平凡,但是垃圾回收执行并不频繁.

## 新生代

通常只有20%左右的新生代会晋升为老生代。老生代空间只有在快被耗尽的时候，才会执行垃圾回收。V8引擎采用了两种回收算法来实现：Scavenge 和 Mark-Sweep 。

Scavenge回收算法运算速度很快，用于新生代；慢一些的Mark-Sweep算法用于老生代。

## Scavenge算法

> Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置中。处于使用中的 semispace 空间成为 From 空间，处于闲置状态的空间成为 To 空间。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将被释放。完成复制后， From 空间和 To 空间的角色发生对换。

## 晋升

对象从新生代移动到老生代的过程为晋升.

From空间到To空间会经过一定检查,满足以下两个条件的对象会晋升:

1. 对象是否经过一次Scavenge回收
2. To空间使用超过25%

## 老生代回收算法: Mark-Sweep & Mark-Compact

Mark-Sweep 有两个阶段:

1. 标记阶段: 遍历对象,标记无引用的对象.
2. 清除对象: 遍历对象,清除无引用的对象.

缺点是导致内存空间不连续

Mark-Compact在Mark-Sweep基础上演变而来的,在第一阶段一边标记对象一边移动活着的对象,然后直接清除死亡的对象和空间.确定是速度很慢,在老生代内存不足的时候才会执行这种算法.

## 增量标记

为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种算法都需要将应用逻辑暂停下来，这种行为称为“全停顿” (stop-the-world)。

由于新生代配置的空间较小，存活对象较少，全停顿对新生代影响不大。但老生代通常配置的空间较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清除、整理等动作造成的停顿就会比较可怕。

为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改成增量标记(Incremental Marking)，也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收和应用逻辑交替执行直到标记阶段完成。

![V8%20GC/Untitled.png](V8%20GC/Untitled.png)